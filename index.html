<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Подарочек - Игра</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background-color: #FFF8DC;
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background-color: #FFF8DC;
        }
        
        /* Стили для мобильной клавиатуры */
        .mobile-keyboard {
            position: fixed;
            bottom: 0;
            width: 100%;
            background: #f0f0f0;
            padding: 10px;
            box-sizing: border-box;
            display: none;
            z-index: 1000;
        }
        
        .keyboard-row {
            display: flex;
            justify-content: center;
            margin-bottom: 5px;
        }
        
        .keyboard-key {
            width: 12%;
            height: 50px;
            margin: 0 2px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .keyboard-key.wide {
            width: 20%;
        }
        
        .keyboard-key.space {
            width: 60%;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1200" height="800"></canvas>
    
    <!-- Виртуальная клавиатура для мобильных устройств -->
    <div class="mobile-keyboard" id="mobileKeyboard">
        <!-- Клавиатура остается без изменений -->
    </div>

    <script>
        // Константы игры
        const SCREEN_WIDTH = 1200;
        const SCREEN_HEIGHT = 800;
        const BACKGROUND_COLOR = "#FFF8DC"; // Светло-желтый
        const TEXT_COLOR = "#503232";
        const BUTTON_COLOR = "#FFB6C1";
        const BUTTON_HOVER_COLOR = "#FF69B4";
        const PANEL_COLOR = "#FFFAF0";
        const CATEGORY_COLORS = [
            "#FFB6C1", // Розовый
            "#ADD8E6", // Голубой
            "#90EE90", // Зеленый
            "#FF6347"  // Красный
        ];

        // Шрифты
        const titleFont = "bold 48px Roboto";
        const headerFont = "bold 32px Roboto";
        const normalFont = "24px Roboto";
        const smallFont = "20px Roboto";

        // Глобальные переменные
        let canvas, ctx;
        let game;
        let startBtn, addPlayerBtn, tasksInput, playerInput;
        let showAnswerBtn, acceptBtn, rejectBtn, continueBtn, newGameBtn;
        let activeInputBox = null;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        class Player {
            constructor(name) {
                this.name = name;
                this.score = 0;
                this.color = this.getRandomColor();
                this.avatar = this.generateAvatar();
            }
            
            getRandomColor() {
                const r = Math.floor(50 + Math.random() * 150);
                const g = Math.floor(50 + Math.random() * 150);
                const b = Math.floor(50 + Math.random() * 150);
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            generateAvatar() {
                const canvas = document.createElement("canvas");
                canvas.width = 80;
                canvas.height = 80;
                const ctx = canvas.getContext("2d");
                
                ctx.beginPath();
                ctx.arc(40, 40, 40, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                const initials = this.name.split(" ")
                    .map(n => n[0])
                    .join("")
                    .toUpperCase()
                    .substring(0, 2);
                
                ctx.font = "bold 32px Roboto";
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(initials, 40, 40);
                
                return canvas;
            }
            
            addScore(points) {
                this.score += points;
            }
        }

        class Game {
            constructor() {
                this.players = [];
                this.currentPlayerIdx = 0;
                this.state = "SETUP"; // SETUP, PLAYING, GAME_OVER, INTERMEDIATE_RESULTS
                this.tasksPerCategory = 50;
                this.setupTasks();
                this.selectedCategory = null;
                this.selectedDifficulty = null;
                this.taskWindowOpen = false;
                this.taskResult = null;
                this.tasksCountInput = "50";
                this.showAnswer = false;
                this.roundCounter = 0;
                this.completedTasks = 0;
                this.totalTasks = 0;
                this.tasksRemaining = 0;
                this.taskOffset = [0, 0, 0, 0];
            }
            
            setupTasks() {
                this.categories = ["Логика", "Творчество", "Слова", "Физподготовка"];
                this.tasks = [];
                
                for (let catIdx = 0; catIdx < 4; catIdx++) {
                    const categoryTasks = [];
                    for (let diff = 0; diff < this.tasksPerCategory; diff++) {
                        const task = {
                            description: this.generateTask(catIdx, diff),
                            completed: false,
                            difficulty: diff + 1,
                            answer: this.getAnswer(catIdx, diff)
                        };
                        categoryTasks.push(task);
                    }
                    this.tasks.push(categoryTasks);
                }
                
                this.totalTasks = 4 * this.tasksPerCategory;
                this.tasksRemaining = this.totalTasks;
            }
            
            generateTask(category, difficulty) {
                // Без изменений
            }
            
            getAnswer(category, difficulty) {
                // Без изменений
            }
            
            startGame() {
                if (this.players.length < 2) return false;
                
                try {
                    const count = parseInt(this.tasksCountInput);
                    if (count < 5 || count > 50) return false;
                    this.tasksPerCategory = count;
                    this.setupTasks();
                    this.state = "PLAYING";
                    this.roundCounter = 0;
                    return true;
                } catch {
                    return false;
                }
            }
            
            addPlayer(name) {
                if (name && this.players.length < 15) {
                    this.players.push(new Player(name));
                    return true;
                }
                return false;
            }
            
            nextPlayer() {
                this.currentPlayerIdx = (this.currentPlayerIdx + 1) % this.players.length;
                
                if (this.currentPlayerIdx === 0) {
                    this.roundCounter++;
                    
                    if (this.tasksRemaining < this.players.length) {
                        this.state = "GAME_OVER";
                    } else {
                        this.state = "INTERMEDIATE_RESULTS";
                    }
                }
            }
            
            selectTask(category, difficulty) {
                if (!this.taskWindowOpen && category >= 0 && category < 4 && 
                    difficulty >= 0 && difficulty < this.tasksPerCategory) {
                    
                    const task = this.tasks[category][difficulty];
                    if (!task.completed) {
                        this.selectedCategory = category;
                        this.selectedDifficulty = difficulty;
                        this.taskWindowOpen = true;
                        this.showAnswer = false;
                        return true;
                    }
                }
                return false;
            }
            
            completeTask(success) {
                if (this.selectedCategory !== null && this.selectedDifficulty !== null) {
                    const task = this.tasks[this.selectedCategory][this.selectedDifficulty];
                    if (!task.completed) {
                        task.completed = true;
                        this.completedTasks++;
                        this.tasksRemaining--;
                        
                        if (success) {
                            const points = task.difficulty;
                            this.players[this.currentPlayerIdx].addScore(points);
                        }
                        
                        this.taskWindowOpen = false;
                        this.nextPlayer();
                        return true;
                    }
                }
                return false;
            }
        }

        class Button {
            // Без изменений
        }

        class InputBox {
            // Без изменений
        }

        // Функции отрисовки экранов
        function drawSetupScreen() {
            // Без изменений
        }

        function drawGameScreen() {
            // Без изменений
        }

        function drawTaskWindow() {
            // Затемнение фона
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            
            // Окно задания
            const windowWidth = Math.min(800, SCREEN_WIDTH - 100);
            const windowHeight = Math.min(500, SCREEN_HEIGHT - 100);
            const windowX = (SCREEN_WIDTH - windowWidth) / 2;
            const windowY = (SCREEN_HEIGHT - windowHeight) / 2;
            
            drawRoundedRect(windowX, windowY, windowWidth, windowHeight, 20, PANEL_COLOR, TEXT_COLOR);
            
            // Заголовок
            const catIdx = game.selectedCategory;
            const task = game.tasks[catIdx][game.selectedDifficulty];
            
            ctx.fillStyle = TEXT_COLOR;
            ctx.font = headerFont;
            ctx.textAlign = "center";
            ctx.fillText(`Задание: Уровень ${task.difficulty}`, windowX + windowWidth / 2, windowY + 40);
            
            // Категория
            ctx.fillStyle = CATEGORY_COLORS[catIdx];
            ctx.fillText(`Категория: ${game.categories[catIdx]}`, windowX + windowWidth / 2, windowY + 90);
            
            // Описание задания
            ctx.fillStyle = TEXT_COLOR;
            ctx.font = normalFont;
            ctx.textAlign = "left";
            ctx.fillText("Задание:", windowX + 50, windowY + 140);
            
            // Разбиение описания на строки
            const description = task.description;
            const words = description.split(" ");
            const maxWidth = windowWidth - 100;
            const lineHeight = 35;
            
            let currentLine = "";
            let lines = [];
            let yPos = windowY + 180;
            
            for (const word of words) {
                const testLine = currentLine + word + " ";
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width < maxWidth) {
                    currentLine = testLine;
                } else {
                    lines.push(currentLine);
                    ctx.fillText(currentLine, windowX + 70, yPos);
                    yPos += lineHeight;
                    currentLine = word + " ";
                }
            }
            
            if (currentLine) {
                lines.push(currentLine);
                ctx.fillText(currentLine, windowX + 70, yPos);
                yPos += lineHeight;
            }
            
            // Кнопки
            const buttonWidth = 180;
            const buttonSpacing = 20;
            yPos += 20;
            
            if (catIdx === 0) { // Логика
                if (game.showAnswer) {
                    // Показываем ответ с переносом строк
                    ctx.fillStyle = "#006400";
                    ctx.fillText("Правильный ответ:", windowX + 50, yPos);
                    yPos += 30;
                    
                    const answerText = task.answer;
                    const answerWords = answerText.split(" ");
                    let answerCurrentLine = "";
                    
                    for (const word of answerWords) {
                        const testLine = answerCurrentLine + word + " ";
                        const metrics = ctx.measureText(testLine);
                        
                        if (metrics.width < maxWidth) {
                            answerCurrentLine = testLine;
                        } else {
                            ctx.fillText(answerCurrentLine, windowX + 70, yPos);
                            yPos += lineHeight;
                            answerCurrentLine = word + " ";
                        }
                    }
                    
                    if (answerCurrentLine) {
                        ctx.fillText(answerCurrentLine, windowX + 70, yPos);
                        yPos += lineHeight;
                    }
                    
                    yPos += 20;
                    
                    // Кнопки принятия/отклонения
                    acceptBtn.x = windowX + windowWidth / 2 - buttonWidth - buttonSpacing / 2;
                    acceptBtn.y = yPos;
                    acceptBtn.draw(ctx);
                    
                    rejectBtn.x = windowX + windowWidth / 2 + buttonSpacing / 2;
                    rejectBtn.y = yPos;
                    rejectBtn.draw(ctx);
                } else {
                    // Кнопка "Показать ответ"
                    showAnswerBtn.x = windowX + windowWidth / 2 - buttonWidth / 2;
                    showAnswerBtn.y = yPos;
                    showAnswerBtn.draw(ctx);
                }
            } else {
                // Для остальных категорий
                acceptBtn.x = windowX + windowWidth / 2 - buttonWidth - buttonSpacing / 2;
                acceptBtn.y = yPos;
                acceptBtn.draw(ctx);
                
                rejectBtn.x = windowX + windowWidth / 2 + buttonSpacing / 2;
                rejectBtn.y = yPos;
                rejectBtn.draw(ctx);
            }
        }

        // Остальные функции рисования без изменений

        // Инициализация игры
        function init() {
            canvas = document.getElementById("gameCanvas");
            ctx = canvas.getContext("2d");
            
            game = new Game();
            
            // Создание элементов UI с исправленными позициями
            startBtn = new Button(SCREEN_WIDTH / 2 - 100, 600, 200, 60, "Начать игру");
            addPlayerBtn = new Button(SCREEN_WIDTH / 2 - 100, 380, 200, 60, "Добавить игрока");
            tasksInput = new InputBox(650, 250, 200, 40, "50");
            playerInput = new InputBox(650, 320, 200, 40);
            
            // Кнопки для окна задания
            showAnswerBtn = new Button(0, 0, 180, 50, "Показать ответ");
            acceptBtn = new Button(0, 0, 180, 50, "Принять", "#90EE90");
            rejectBtn = new Button(0, 0, 180, 50, "Отклонить", "#FF6347");
            
            // Кнопки для других экранов
            continueBtn = new Button(0, 0, 200, 60, "Продолжить игру");
            newGameBtn = new Button(0, 0, 200, 60, "Новая игра");
            
            // Инициализация мобильной клавиатуры
            if (isMobile) {
                const keyboard = document.getElementById('mobileKeyboard');
                const keys = keyboard.querySelectorAll('.keyboard-key');
                
                keys.forEach(key => {
                    key.addEventListener('click', function() {
                        if (!activeInputBox) return;
                        
                        const action = this.getAttribute('data-action');
                        if (action === 'backspace') {
                            activeInputBox.text = activeInputBox.text.slice(0, -1);
                        } else if (action === 'space') {
                            activeInputBox.text += ' ';
                        } else if (action === 'enter') {
                            // Обработка Enter
                            if (activeInputBox === playerInput) {
                                if (game.addPlayer(playerInput.text)) {
                                    playerInput.text = "";
                                }
                            }
                        } else {
                            activeInputBox.text += this.textContent;
                        }
                    });
                });
            }
            
            // Запуск игрового цикла
            requestAnimationFrame(gameLoop);
        }

        function gameLoop() {
            // Без изменений
        }

        // Обработчики событий
        function handleMouseMove(event) {
            // Без изменений
        }

        function handleMouseDown(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            if (game.state === "SETUP") {
                // Проверка клика по полям ввода
                if (tasksInput.isPointInside(mouseX, mouseY)) {
                    tasksInput.activate();
                    playerInput.deactivate();
                    activeInputBox = tasksInput;
                } else if (playerInput.isPointInside(mouseX, mouseY)) {
                    playerInput.activate();
                    tasksInput.deactivate();
                    activeInputBox = playerInput;
                } else {
                    tasksInput.deactivate();
                    playerInput.deactivate();
                    activeInputBox = null;
                }

                // Затем проверка кнопок
                if (addPlayerBtn.isClicked(mouseX, mouseY)) {
                    if (game.addPlayer(playerInput.text)) {
                        playerInput.text = "";
                    }
                } else if (startBtn.isClicked(mouseX, mouseY)) {
                    game.tasksCountInput = tasksInput.text;
                    if (game.startGame()) {
                        // Игра успешно начата
                    }
                }
            }
            else if (game.state === "PLAYING") {
                if (game.taskWindowOpen) {
                    // Обработка кнопок
                    if (showAnswerBtn.isClicked(mouseX, mouseY)) {
                        game.showAnswer = true;
                    }
                    else if (acceptBtn.isClicked(mouseX, mouseY)) {
                        game.completeTask(true);
                    }
                    else if (rejectBtn.isClicked(mouseX, mouseY)) {
                        game.completeTask(false);
                    }
                } else {
                    // Обработка выбора задания
                    const categoryWidth = (SCREEN_WIDTH - 100) / 4 - 10;
                    for (let i = 0; i < 4; i++) {
                        const x = 50 + i * (categoryWidth + 10);
                        if (mouseX >= x && mouseX <= x + categoryWidth && mouseY >= 150 && mouseY <= 750) {
                            const tasksPerRow = 5;
                            const taskSize = 30;
                            const spacing = 10;
                            const startY = 230;

                            const totalWidth = tasksPerRow * taskSize + (tasksPerRow - 1) * spacing;
                            const startX = x + (categoryWidth - totalWidth) / 2;

                            const startIdx = game.taskOffset[i];
                            const endIdx = Math.min(startIdx + tasksPerRow * 10, game.tasksPerCategory);

                            for (let j = startIdx; j < endIdx; j++) {
                                const row = Math.floor((j - startIdx) / tasksPerRow);
                                const col = (j - startIdx) % tasksPerRow;

                                const taskX = startX + col * (taskSize + spacing);
                                const taskY = startY + row * (taskSize + spacing);

                                // Проверяем расстояние до центра круга
                                const distance = Math.sqrt(Math.pow(mouseX - taskX, 2) + Math.pow(mouseY - taskY, 2));
                                if (distance <= taskSize/2) {
                                    // Клик по заданию j в категории i
                                    game.selectTask(i, j);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            else if (game.state === "INTERMEDIATE_RESULTS") {
                if (continueBtn.isClicked(mouseX, mouseY)) {
                    game.state = "PLAYING";
                }
            }
            else if (game.state === "GAME_OVER") {
                if (newGameBtn.isClicked(mouseX, mouseY)) {
                    // Перезапуск игры
                    game = new Game();
                    tasksInput.text = "50";
                    playerInput.text = "";
                }
            }
        }

        // Остальные обработчики без изменений

        // Запуск игры при загрузке страницы
        window.addEventListener("load", init);
        window.addEventListener("mousemove", handleMouseMove);
        window.addEventListener("mousedown", handleMouseDown);
        window.addEventListener("keydown", handleKeyDown);

        // Обработчики для мобильных устройств
        window.addEventListener("touchmove", (e) => {
            e.preventDefault();
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const mouseX = touch.clientX - rect.left;
                const mouseY = touch.clientY - rect.top;
                handleMouseMove({clientX: touch.clientX, clientY: touch.clientY});
            }
        }, {passive: false});

        window.addEventListener("touchstart", (e) => {
            e.preventDefault();
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const mouseX = touch.clientX - rect.left;
                const mouseY = touch.clientY - rect.top;
                handleMouseDown({clientX: touch.clientX, clientY: touch.clientY});
            }
        }, {passive: false});
    </script>
</body>
</html>
